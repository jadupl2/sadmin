#! /bin/bash
#=============================================================================
# Title      :  sam.init - sam initialization script
# Version    :  1.0
# Author     :  Jacques Duplessis
# Date       :  2005-01-06
# Requires   :  bash shell
# SCCS-Id.   :  @(#) sam.init 1.0 5-Jan-2005
# Update in 2014
# NEW LINE
#=============================================================================
#
# Description
#   This is the first script is called by sam when it start
#       - It load in memory all functions used by sam.
# ----------------------------------------------------------------------------
# V 1.4 Modified to support Red Hat 5.0 (no more ext2online back to resize2fs
#
#=============================================================================
trap 'exit 0' 2   # INTERCEPTE LE ^C




#=============================================================================
#                  V A R I A B L E S      D E F I N I T I O N S
#=============================================================================
PN=${0##*/}      					; export PN	# Program name
VER="5.3"							; export VER	# Program Version
USAGE="Usage : sam "            	; export USAGE
#stty erase "^H"                      # Make sure backspace work as expected

# To Activate Debug DEBUG="ON" 
# To turn Debug off DEBUG=""
DEBUG="ON"
DEBUG=""

# Screen related variables
clreol=`tput el`             		; export clreol     # Clear to end of line
clreos=`tput ed`             		; export clreos     # Clear to end of screen
bold=`tput bold`             		; export bold       # bold attribute
bel=`tput bel`               		; export bel        # Ring the bell
rvs=`tput rev`               		; export rvs        # reverse video attribute
nrm=`tput sgr0`              		; export nrm        # normal attribute
unl=`tput smul`              		; export unl        # UnderLine
home=`tput home`             		; export home       # home cursor
up=`tput cuu1`               		; export up         # cursor up
down=`tput cud1`             		; export down       # cursor down
right=`tput cub1`            		; export right      # cursor right
left=`tput cuf1`             		; export left  	    # cursor left
clr=`tput clear`             		; export clr	    # clear the screen
blink=`tput blink`           		; export blink      # turn blinking on
screen_color="\E[44;38m"      		; export screen_color # (BG Blue FG White) 

# SAM Variables
SAM="/sadmin/sam"					; export SAM
SAMTMP="$SAM/tmp"					; export SAMTMP
SAMFILES="$SAM/files"				; export SAMFILES 
SAMLANG="$SAMFILES/sam_lang.seq"	; export SAMLANG
SAMCIE="$SAMFILES/sam_cie.seq"		; export SAMCIE
SAMTAPE="$SAMFILES/sam_tape.seq"	; export SAMTAPE
SAMVG="$SAMFILES/sam_vg.seq"		; export SAMVG
SAMDAILY="$SAMFILES/sam_daily.seq"	; export SAMDAILY
SAMWEEKLY="$SAMFILES/sam_weekly.seq"; export SAMWEEKLY
SAMLOG="$SAMTMP/manager.log"		; export SAMLOG     # SAM Log file
SAMLIST="$SAMTMP/liste.seq"			; export SAMLISTE
HOSTNAME=`hostname`					; export HOSTNAME
WDATA=""                            ; export WDATA      # Input Value entered
MTLIB="/usr/bin/mtlib"              ; export MTLIB
COMPAGNIE="Standard Life Canada"	; export COMPAGNIE
linux_release=`cat /etc/*-release`  ; export linux_release
CREATE_GROUP_NODE="lxmq0007.slac.ca"; export CREATE_GROUP_NODE


# OSNAME = Current Linux OS
#===============================================================================
if [ -f /etc/redhat-release ] ; then OSNAME="RedHat" ; fi
if [ -f /etc/fedora-release ] ; then OSNAME="Fedora"  ; fi
if [ "$OSNAME" = "RedHat" ] 
   then grep -i centos /etc/redhat-release >/dev/null 2>&1
        if [ $? -eq -0 ] ; then OSNAME="CentOS" ; fi
fi
export OSNAME


# OSVERSION = RedHat (CentOS) Version based on kernel version
#===============================================================================
OSVERSION=7     # Default Value
kver=`uname -r | awk -F"." '{ print $1 $2 $3 }' | awk -F"-" '{ print $1 }'` 
if [ $kver -eq 2632 ] ; then OSVERSION=6 ; fi
if [ $kver -eq 2618 ] ; then OSVERSION=5 ; fi
if [ $kver -eq 269  ] ; then OSVERSION=4 ; fi
if [ $kver -eq 2421 ] ; then OSVERSION=3 ; fi
if [ $kver -eq 249  ] ; then OSVERSION=2 ; fi
export OSVERSION

kernel_version=`uname -r | awk -F. '{ printf "%s.%s.%s", $1,$2,$3 }'`



# Create important Directory if they do not exist
#=============================================================================
if [ ! -d $SAMTMP ]   ; then mkdir $SAMTMP   ; fi
if [ ! -d $SAMFILES ] ; then mkdir $SAMFILES ; fi




# Determine if running within a cluster - if so go cluster info
#=============================================================================
CLUSTER_CFG="/etc/cluster/cluster.conf"
if [ -x /usr/sbin/clustat ] && [ -r $CLUSTER_CFG ] 
   then CNAME=`sed  's/\"//g' $CLUSTER_CFG |tr -d '>' |grep -i config_version |awk '{ print $4 }'|awk -F= '{ print $2 }'`
        CNBNODE=`grep -i "clusternode name" /etc/cluster/cluster.conf | wc -l`
        CLUSTER="Y"
   else CLUSTER="N"
fi 
CNODEFILE="/cadmin/etc/cluster_nodes.txt"




#===============================================================================
#  Display Message on the line and position receive as parameter
#  writexy "Message" 12 50
#=============================================================================
writexy()
{
     tput cup `expr $1 - 1`  `expr $2 - 1`   # tput command pos. cursor
     echo -e "$3\c"                          # Display Message
}



#=============================================================================
# Ask a question at line and position specified
# function return 0, if user answered "no" and return 1 if answered "yes"
# parameters received are line,position, message
#=============================================================================
messok()
{
   wline=$1 ; wpos=$2 ; wreturn=0
   wmess="$3 [y,n] ? "
   writexy $1 $2 "                                                "
   while :
     do
      writexy $1 $2 "$wmess  ${right}${right}"
      read answer
      case "$answer" in
           o|O|Y|y ) wreturn=1
                     break
                     ;;
           n|N     ) wreturn=0
                     break
                     ;;
                 * ) ;;
      esac
    done
   return $wreturn
}


#=============================================================================
# DISPLAY MESSAGE RECEIVE AT LINE 23 & WAIT FOR RETURN
#=============================================================================
mess()
{
   writexy 22 01 "${clreos}${bold}${1}${nrm}${bel}${bel}"
   writexy 23 01 "Press [ENTER] to continue."
   read dummy
   writexy 22 01 "${clreos}"
}





#=============================================================================
# Display Blinking Message while loading
#=============================================================================
if [ ! "$NODISPLAY" ]
   then tput clear
        echo "${rvs}Loading in progress - One Moment Please${nrm}"
fi




#=============================================================================
# Construct Manager Password
#=============================================================================
MPASSE=`date +%d%m%y`			; MPASSE=`expr $MPASSE + 444 `
MPASSE=`expr $MPASSE \* 2 `		; export MPASSE
echo "`date +%d`+`date +%m`+`date +%y`" | bc > /tmp/SAMPAS$$ 
MPASSE2=`cat /tmp/SAMPAS$$` 		; export MPASSE2
rm /tmp/SAMPAS$$


# Calculate Version Position on the Heading line
#=============================================================================
long=`echo $OSNAME | awk '{ printf "%d",length() }'`
VERSION_POS=`expr 2 + $long `


# Calculate HOSTNAME Position on the Heading line
#=============================================================================
long=`echo $HOSTNAME | awk '{ printf "%d",length() }'`
HOSTNAME_POS=`expr 81 - $long `





#=============================================================================
# Clear Screen and display the 2 heading lines of SAM
#=============================================================================
display_entete()
{
   titre=`echo $1` 			     # Menu Title
   forty_spaces="                                        "
   eighty_spaces="$forty_spaces                                        "

# Affiche deux lignes en reverse video sur les deux premieres lignes
   echo -e "${clr}${bold}${rvs}\c"
   echo -e "\e[1m"
   writexy 01 01 "$eighty_spaces" 
   writexy 02 01 "$eighty_spaces" 
   writexy 21 01 "$eighty_spaces" 

# Calculer la position pour centrer le nom de compagnie sur la ligne 
   TITLE=$COMPAGNIE
   long=`echo $TITLE | awk '{ printf "%d",length() }'`
   wpos=`expr 80 - $long `
   wpos=`expr $wpos / 2 `

# Display premiere ligne de l'entete
   #writexy 01 01 "`date +%d/%m/%y`"	
   writexy 01 01 "Kernel $kernel_version" 
   writexy 01 $wpos "$TITLE" 
   writexy 01 77 "$VER" 


# Display OS Name and OS Version
   writexy 02 01 "$OSNAME Ver.$OSVERSION"
   writexy 02 "$HOSTNAME_POS" "$HOSTNAME"

# Display Titre du Menu
# Calculer la position pour centrer le titre sur la ligne de 80 colonnes
   long=`echo $1 | awk '{ printf "%d",length() }'`
   wpos=`expr 80 - $long `
   wpos=`expr $wpos / 2 `
   writexy 02 $wpos "$titre"

# Reset to normal mode
   echo -e "${nrm}\c" 
   writexy 04 01 ""
}






#=============================================================================
# DISPLAY MESSAGE ON LINE 22 
#=============================================================================
displayMessage()
{
   writexy 22 01 "${clreos}"
   writexy 22 01 "${bold}${1}${nrm}${bel}"
}




#=============================================================================
# ASK THE MANAGER PASSWORD
#=============================================================================
ask_password()
{
   writexy 22 01 "${clreos}${bel}${bel}"
   writexy 22 01 "Please enter the manager password ...  ? "
   stty -echo
   read REPONSE
   stty echo
   if [ "$REPONSE" != "$MPASSE" ] && [ "$REPONSE" != "$MPASSE2" ] 
      then mess "Invalid password" 
           return 0
      else
	   return 1
   fi
}




#=============================================================================
# Param #1 = Position the cursor on that line number
# Param #2 = Cursor position on the line
# Param #3 = Number of Character to accept
# Param #4 = Type of accept A=AlphaNumeric N=NUmeric
# Param #5 = Value of field just entered
#=============================================================================
accept_data()
{
  while : 
        do
        WBLANK="                              "
        WLINE=$1			                # Line to accept Data
        WCOL=$2			                    # Column to accept data
        WLEN=$3			                    # Max Field Length
        WTYPE=$4                            # AlphaNum = A, Numeric = N
        if [ "$WTYPE" != "N" ] ; then WTYPE="A" ; fi
        WDEFAULT=$5			                # Default Value
        WDATA=$WDEFAULT
        a=1 ; WMASK="" ;
        while [ $a -le "$WLEN" ]
              do
              a=$(($a+1))
              WMASK="${WMASK} "
              done
        if [ "$WDEFAULT" = "NULL" ] ; then WDEFAULT="" ; fi
        if [ "$WCOL" != "" ]
           then writexy $WLINE $WCOL "${rvs}${WMASK}"
	        writexy $WLINE $WCOL "${WDEFAULT}${nrm}"
        fi

        # Accept the Data
        writexy $WLINE $WCOL "" 
        #read -n${WLEN} WDATA
        read WDATA
        if [ "$WDATA" = "" ]    ; then WDATA="$WDEFAULT"  ; fi
        if [ "$WDATA" = " " ]   ; then WDATA=""           ; fi
        if [ "$WDATA" = "-" ]   ; then WDATA=""           ; fi
        if [ "$WDATA" = "del" ] ; then WDATA=""           ; fi
        if [ "$WLEN" != "0" ]
           then writexy $WLINE $WCOL "${WMASK}"
                writexy $WLINE $WCOL "$WDATA"
        fi

	    # Test if length of data excedd what was requested
        if [ ${#WDATA} -gt ${WLEN} ]
           then mess "Only ${WLEN} characters are accepted for this field"
                continue
        fi

        # If numeric was wanted - Test all char for numbers
        if [ "$WTYPE" = "N" ]
           then echo $WDATA | grep [^0-9] > /dev/null 2>&1
                if [ "$?" -eq "0" ]
                   then mess "Sorry, wanted a number"
                   else break                          
                fi
           else break
        fi 

        done
}




#=============================================================================
# Pour s'assure qu'un fichier ne depasse pas 2000 entree
#=============================================================================
StripFile()
{
    wstrip=$1
    if [ -r "$wstrip" ] 
	then
	tail -5000 $wstrip > /tmp/$$
	rm -f $wstrip
	cp /tmp/$$ $wstrip
	rm -f /tmp/$$
    fi
}
